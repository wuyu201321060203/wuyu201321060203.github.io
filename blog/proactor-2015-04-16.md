现代操作系统为开发并发应用提供了多种机制，同步多线程模型也许是其中最“自然”和著名的一种。然而，线程固有的性能“天花板”，以及复杂的同步语义都催生操作系统去支持新的，更易用的编程模型。比如本文要讲解的Proactor网络编程模式：通过纯异步+I/O多路复用的方式，既可以提高网络应用的并发性，同时又能一定程度上降低多线程模型中的性能瓶颈和同步复杂度。

####闲扯开篇

我个人认为Proactor网络编程模型是把能使用的“好”的网络应用编程机制恰如其分的结合在了一起。为什么这么讲？相比纯多线程编程模型，Proactor将线程主要分为控制线程和工作线程，层次的划分带来的好处就是网络通信与业务逻辑的解耦，同时能提高系统的吞吐量。相比于Reactor编程模型这种反应堆式的I/O（虽然可以有几个I/O线程），Proactor完全异步的I/O能最大化利用I/O子系统的能力，提高并发性和吞吐量。它适用于当应用非常需要并发性来提高性能，又不想有同步多线程模型和reactor模型的一些限制的场景。下文开始以图1-1的例子进行剖析，一个高性能Web服务器需要并发地处理来自客户端的HTTP请求，下图给出了一个传统的Web浏览器和Web服务器之间交互流程。当一个用户操作浏览器打开一个URL，浏览器会向Web服务端发送一个HTTP GET请求报文。服务器接到请求首先解析，明确请求内容，然后把指定的文件发给浏览器。

图1-1

开发高性能Web服务器必须实现以下指标：
- 并发性——Web服务器必须能够并发地处理来自多个用户的请求。
- 高效性——Web服务器必须最小化延迟，最大化吞吐量，充分利用CPU等系统资源。
- 编程简洁性——服务器设计时能够简化并发机制的运用。
- 可扩展性——集成或支持新的的通信协议时需要最小化维护和开发代价。

一个Web服务器实现时可以使用多种并发机制，包括同步多线程模型，reactor同步事件分发，proactor异步事件分发。接下来我们先看一下传统方法的局限性，然后解释为什么说Proactor提供了一种更为强大的，有效的，灵活的开发高性能并发应用的方式。

####传统模型的缺陷

#####同步多线程并发模型

也许是一种最自然的用来实现并发Web服务器的方法，见图2-1。在这种模型中，多个服务器线程并发地处理来自客户端的HTTP GET请求。线程之间是完全平等的，每一个线程独立处理连接建立，请求读取，请求解析和文件同步传输流程。每个线程必须处理完当下完整的操作流程后才能接受下一个请求并开始新一轮的处理，即使这个处理流程有可能阻塞。这种模型的好处就是编程思维复杂度低，处理A用户请求和B用户请求是互相独立的，共享状态少，能够降低同步代价。然而这种模型也存在着如下缺陷：
1. 线程之间平等的关系导致如果线程因为某个操作阻塞住，无法为新用户服务的话，系统整体的吞吐量会很低。
2. 线程策略和并发策略是紧耦合的关系，每个线程都全职为一个连接服务，基本上就是线程策略等于并发策略。
3. 大量线程切换带来的性能下降

#####基于Ractor的同步事件分发模型

另一种比较常见的用来实现Web服务器的模型是Reactor模型，见图2-2。一个单线程并发服务器通过事件循环阻塞地等待I/O事件发生，当事件发生时这个Reactor会告知事件解复用设施哪些套接字可读可写，进而去调用对应的回调钩子。这种模式平时比较常用就不做详细说明了，它的缺点就是编程思维零碎化，因此有人提出用协程来处理，请见文章...。另外一个问题是Reactor模式对回调是没有优先级之分的，也就是没有什么调度策略去支持你的特殊需求，大家就按照顺序Reactor通知的顺序进行I/O然后进行业务处理。

#####基于Proactor的异步并发模型

当操作系统支持异步操作时，一个实现Web服务器有效的方式是使用前摄式的事件分发机制，见图2-3。一个异步的Web服务器首先要向OS发起一个异步I/O类操作，并注册一个回调钩子和事件解复用设施实例。然后OS就会代表该Web服务器执行I/O操作，I/O完成后OS会将结果放置在一个约定好的位置并通知事件解复用设施实例。事件解复用器则会检查返回的结果组成的队列，拿到返回结果并执行对应的回调钩子。下图展示了这一流程：

使用Proactor模型的主要好处是大量并发操作可以几乎以并行的方式进行，不需要应用程序显示创建线程，这些操作以异步的方式在OS的IO子系统中进行直到结束，因此发起异步IO的线程可以立即处理其他请求。Proactor模型的主要缺陷是编程逻辑难度相比Reactor有过之无不及，并且非常难于调试，因为异步操作的运行是不可预知，场景难以重现。当出现以下条件时可以考虑使用Proactor模式。
- 一个应用需要执行一个或者多个异步操作，但是不能阻塞调用线程
- 当异步操作完成时需要通知应用主线程（控制线程）
- 应用需要网络通信和业务解耦
- 当应用使用多线程模型或者基于Reactor模型性能达到要求的时候

####Proactor的结构和主要组件

Proactor模型结构如图3-1所示：
图3-1

其主要组件包括以下几个部分：

（1）Proactive Initiator（Web服务器主线程）：
Proactive Initiator可以是任何发起异步操作的实体，它负责注册异步操作完成的回调句柄和一个事件分发器（解复用设施）。
（2）Completion Handler（完成句柄）：
处理异步操作结果
（3）异步操作：
异步操作指代替应用执行操作请求（例如I/O请求或者定时请求）。当应用发起一个异步操作，这个操作不会干扰应用主线程的运行。因此，从应用程序的角度，这些操作时异步进行的。当异步操作完成，事件完成分发器会被通知。
（4）异步操作处理器：
一般操作系统，不需要我们关心。
（5）事件完成分发器：
当分发事件完成时，事件完成分发器负责执行回调钩子。

####Proactor的优势与劣势小结
Proactor的优势有：
1. 将应用需要的异步机制同业务代码解耦，应用只需关心执行其专属服务。
2. 屏蔽下层操作系统支持异步I/O的细节，其实就是更好的封装与架构。
3. 应用程序不需要显示创建线程来提高并发性，因此将应用的线程策略和并发策略解耦。应用可以选择不同的事件完成分发器，比如既可以是单线程的也可以是线程池的。
4. 应用由于无需自己创建额外的控制线程，因此同步逻辑得以简化。
5. 性能提升。
Proactor的主要劣势就是调试困难，带有异步属性的程序共有的毛病。

####Proactor杂谈
仅就Linux Posix支持的异步I/O接口而言，connect和accept是无法异步操作的，这时一般借用Reactor的机制去感知主动连接或者被动连接成功，再用这个套接字描述符发起异步操作。对于一般网络框架都需要提供的定时功能来说，为了与Proactor这一套机制集成，一般会有一根特殊的管道，发起定时任务后，会有个异步线程接收定时任务完成计时，到时后会向管道发送特殊标识，框架会一直有个异步读操作读这根管道，一旦时间到，异步操作返回，然后就照常通知事件完成分发器，照常回调。对于事件分发器，主要由三种策略获取OS的完成事件通知：
1. 信号量唤醒机制
2. 通过aio_suspend这种系统调用，内部实现还是借用Reactor思想，通过注册事件完成通知。
3. 直接把事件完成的回调钩子扔给异步操作，OS代替应用程序执行完I/O后调用。

