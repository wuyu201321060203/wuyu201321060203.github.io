---
layout: post
title:  Sinfonia：构建可伸缩分布式系统的新范式
category: articles
tags: distributed-system scalable new-paradigm

image:
     feature: head20.jpg

author:
     name:   WuYu
     avatar: bio-photo-alt.jpg

comments: true
share: true
---

###Sinfonia简介

Sinfonia对分布式系统的构建提出了更高层次的抽象，将分布式系统所需要的伸缩性，容错等基本特征抽象成一个服务层，而分布式文件系统，分布式消息系统或者其他分布式系统则成为其上层架构级应用。它们不再需要处理复杂的消息协议，直接利用Sinfonia操作数据结构即可。Sinfonia服务的核心是一个小巧的迷你事务层，该事务层在提供快速和一致的数据存取的同时掩盖了并发，错误恢复所带来的复杂性。总之Sinfonia是一个实现了容错，伸缩性和一致性的分布式系统基本特征的，允许应用共享海量数据的服务。

Sinfonia在功能性和伸缩性上进行了权衡。它通过对不同hosts的操作进行解耦，令这些操作尽量独立运行的方式实现系统可伸缩。为实现这个目标，Sinfonia提供细粒度的地址空间来存储数据，这些数据没有任何格式，类型，模式要求，因此应用可以互相独立地操作数据。Sinfonia的架构如下图：

![](/images/Sinfonia1.png)

Sinfonia的核心是一个轻量级的迷你事务层，它允许应用原子性访问和条件更改memory node上的数据。迷你事务除了操作上的简化外，对于性能的提高也很有帮助。首先，迷你事务有利于操作批处理进行，这些操作经过一轮网络交互就可以提交给系统执行。其次，迷你事务的具体操作可以混肴在两阶段提交协议交互中，进一步减少网络交互次数。最后，迷你事务可以很容易的进行复制操作，为系统提供可用性。

###Sinfonia设计

Sinfonia的设计基于两个重要原则：

- 通过为服务提供无结构和模式数据来减少操作依赖。
- 为模块进行可伸缩性设计前先解决好单节点或者小规模节点的可靠性。

Sinfonia由一系列的memory nodes和运行在客户应用程序节点的客户端库组成。memory nodes持有应用数据，根据应用的需求，数据可以放在RAM中也可以放在磁盘等持久存储里。客户端库实现了memory nodes上数据的操作语义。每个memory node保存有一个原始的，等宽的words序列，宽度一般是一字节一个，这些字节组成了没有任何结构的线性地址。每个memory node都有自己的线性地址空间，因而索引时需要通过(memory-node-id，address)二元组指明是哪个memory node。Sinfonia没有采用一个全局地址空间的原因是：通过分而治之，更细化的地址空间控制有利于应用将关联数据存放在同一个memory node上。虽然牺牲了一些吞吐量但是却可以极大的提高系统伸缩性。application nodes通过客户端库访问数据，这个客户端库提供单个memory node的byte range读写和迷你事务操作。

###迷你事务

迷你事务允许应用程序以原子性，一致性，隔离性和持久性（如果需要）的语义跨memory nodes更新数据。传统的分布式事务操作可以粗略地表述为：首先有一个协调者发动参与者执行一个或者多个事务操作。在事务操作结束时，协调者开始两阶段提交过程，第一阶段协调者询问所有参与者是否准备好提交，如果所有参与者都回答yes，协调者在第二阶段向参与者发消息让它们提交事务，否则中止。Sinfonia通过将整个事务操作与两阶段提交协议第一阶段集成的方式减少网络交互，提高性能。

一个迷你事务如下图所示，它由一系列compare items，read items和write items组成。

![](/images/Sinfonia2.png)

每个item需要指定一个memory node和address range，如果是compare或者write item 还要包含具体数据，每次在事务开始执行前选择好items。在执行期间，迷你事务需要按下列规约执行：

- compare items用其地址内的数据（系统中的数据）和自带数据作等值比较
- 如果所有比较操作都成功或者没有compare items，read items返回指定地址数据，write items更新指定地址数据
- 如果任何一个compare item失败，事务abort

用这种最基本的语义可以实现很多功能强大的分布式数据操作，比如swap，compare-and-swap，atomic read of many data，acquire a lease，acquire multiple leases atomically，change data if lease is held等。

Sinfonia不做任何的数据缓存，这部分工作交给应用自己实现。

###容错机制

Sinfonia为应用提供容错机制，即使application nodes挂掉也不会影响Sinfonia中的数据（迷你事务具有原子性）。除此之外，Sinfonia还提供下列可选的保护措施：

1.	系统中几个memory node宕机的情况不影响系统继续工作
2.	如果很多带有持久化存储介质的memory nodes在几乎同一时间挂掉，系统保证数据不会丢失，但可能需要一段时间来恢复服务
3.	如果memory nodes和它们的持久存储都崩了（比如遭遇自然灾害），Sinfonia使用事务一致的数据备份来恢复数据

Sinfonia通过四种机制实现容错，分别是磁盘镜像，日志，复制和备份。一个磁盘镜像保存一份memory node上数据的副本，为了更加高效，磁盘镜像是异步写下去的，因此可能会有一点更新不及时。为了弥补这点，会有一个日志记录最近的数据更新信息，日志是同步写下去的。日志可以存储在磁盘上也可以存储在非易失性RAM（NVRAM）上。如果一个memory node需要故障恢复，它会采用一个恢复算法来重演日志，这对应用是透明的，但是恢复可能需要一段时间，这段时间服务暂时不可用。为了保证高可用，Sinfonia也可以复制memory nodes数据，即使一个memory node挂了，一个副本可以立即切过来进行服务，当前Sinfonia使用主副本策略进行复制。备份是由具有事务一致性的数据镜像生成，这个镜像可以在不中断对应用服务的情况下生成。复制协议是为多副本准备的，是分布式系统自身一个长期的操作过程，而备份操作是由客户节点偶尔发起的操作。

###其他设计策略

Sinfonia没有为应用提供负载均衡机制，但是可以向应用提供系统中所有memory nodes分门别类的负载信息。负载均衡有时会涉及数据迁移问题，这个可以通过迷你事务来解决，然而数据什么时间和往哪迁移需要应用开发者自己实现。

###具体实现和算法

####基本架构

Sinfonia由一系列memory nodes和各个application nodes上的客户端库组成。这个客户端库和memory nodes通过RPC进行通信，迷你事务协议跑在这个RPC上面。memory nodes上跑着一个Sinfonia服务进程，它负责管理数据，迷你事务的redo日志和运行复制协议。

####迷你事务协议

根据前文所述，Sinfonia的迷你事务在两阶段提交的第一阶段集成了事务操作。这种新的两阶段提交机制也反映出了一些新的系统错误假设。在标准的两阶段提交中，如果一个协调者挂了，系统就会阻塞直到协调者恢复正常，这种情况在Sinfonia是不能发生的，因为协调者是跑在application nodes上的，不是memory nodes，而application nodes什么情况都有可能发生，我们不能让它们影响系统。这里采用的解决方案是让阻塞发生在参与者身上而不是协调者身上，在Sinfonia中协调者需要访问参与者的数据，因此如果参与者阻塞，协调者必然阻塞。同时要注意，因为Sinfonia可以有选择地复制memory nodes数据，所以除非是所有副本都挂了事务才会阻塞，一般都不会阻塞。

这里的两阶段提交协议，协调者没有日志，我们认为一个事务成功提交必须是所有参与者在它们各自的日志中对这个事务投了yes票。为了保证事务的隔离性，迷你事务第一阶段操作需要锁住涉及的地址空间一小段时间，第二阶段就会释放。我们通过一种简单的机制防止死锁，一个参与者会试图去获得锁，如果拿不到则必须释放所有已持有的锁，然后对该事务投”abort due to busy lock”。如果协调者发现是因为这个原因导致事务不能提交，那么可以在以指数增长的时间段后重试。

####迷你事务细节

迷你事务的第一阶段，协调者需要先生成一个事务号，然后把这个事务发给所有参与者。每个参与者收到后(a)锁住其items涉及的地址空间，(b)执行compare items的比较操作，如果所有比较操作都成功，read items可以读数据，但是write items先缓存着，(c)决定投票，决定依据是所有需要锁住的地址能锁住并且所有比较操作成功，投yes否则投no。阶段2是如果所有参与者投了yes，协调者通知参与者提交事务，协调者应用write items，最后释放锁。迷你事务的伪代码如下图：

![](/images/Sinfonia3.png)

如果日志是被允许的，第一阶段迷你事务会记录redo日志，只有write items需要记日志，日志采用WAL（write-ahead-log）技术提高性能（因为日志是append的顺序写操作）。参与者有一个in-doubt清单，该清单记录所有还没有决定结果的事务号，一个forced-abort清单，记录必须投abort的事务号和一个decided清单，记录所有完成的事务号以及结果。具体清单类型和解释如下图所示：

![](/images/Sinfonia4.png)

####协调者宕机恢复机制

如果协调者挂了，迷你事务很可能留下一些不确定结果（因为有可能一些参与者还没投票）。为了解决这个问题，系统引入特殊的recovery 协调者，它跑在特定的管理节点上。恢复机制必须保证：（a）如果在恢复过程中recovery协调者或者memory nodes挂了，系统不能进入一个不可恢复状态；（b）即使原协调者还活着，执行着并发操作也不影响正确性；（c）允许多个recovery协调者并发执行。

为了恢复一个事务号为tid的迷你事务，recovery协调者首先先要abort它，因为这个recovery协调者对要恢复的事务还一无所知。简单地说，recovery协调者需要执行以下两个步骤，第一步要求事务参与者投abort，每个参与者检查自己之前是否投过这个事务，如果投过保持之前的投票，否则必须选择投abort，将该事务放到forced-abort清单中，这个是防止原协调者“诈尸”后让它们投票，引起两次投票结果不一致。这两种情况任何情况下参与者都需要进行回复。第二阶段和正常事务第二阶段相同，只不过recovery协调者取代了正常协调者而已。recovery协调者如何获得触发呢？运行recovery协调者的管理节点会定期的试探memory nodes上in-doubt清单中的事务，如果试探多次之后这个事务还是没有明确结果就启动恢复流程。

####参与者宕机恢复机制

当一个参与者memory node宕机时，系统会阻塞所有还在执行中的，该宕机memory node涉及的迷你事务，直到宕机memory node恢复。如果这个参与者丢失了持久化存储，那么它需要从backup恢复。更一般的情况是memory node恢复时是带有持久化存储的，在这种情况下只需要通过重演redo日志的方式同步磁盘镜像即可。为避免长时间重演日志，会有一个类似检查点的东西表明哪部分日志是需要重演的。注意不是所有迷你事务都需要恢复，只需要恢复已经提交的事务，而已提交事务可由decided清单获取。decided清单是异步写到磁盘的，有可能会有一点不实时，即会出现一些redo日志中有但是decided清单没有的事务，这时需要联系这些事务涉及的memory node，视它们的投票结果做决定。

####系统整体崩掉恢复机制

如果系统中有太多memory nodes宕机或者重启，管理节点需要开始一个恢复流程一次性恢复尽可能多的memory nodes。每个memory nodes都会按照之前介绍过的步骤恢复自身，这里有一个小小的优化：memory nodes会彼此互发它们关于最近事务的投票结果，因此如果有一个memory node上有一个任务，它在redo日志中但是不在decided清单中，则这个memory node不再需要联络其他参与者就可以进行恢复了。管理节点如何得知系统大面积memory nodes崩溃呢？这里采用了一个简单的机制：当一个memory node重启时，它会向管理节点发送一个重启通知，这时管理节点会以此作为契机试图联系其他memory nodes，等待它们的在线回复或者重启通知，如果收到大部分节点都是重启通知，那就意味着很多节点挂掉和重启了。

####日志垃圾收集

一个memory node将已提交的事务应用到磁盘镜像上，所以redo日志可以被垃圾回收。redo日志是按照日志序列号顺序收集的。如果日志头有一个aborted事务，那么它可以被立即收集。最麻烦的是收集已经提交的事务，这部分工作需要严格遵守下列规则：

一个已经提交的事务tid如果可以从redo日志头移除，那么该事务涉及的所有memory node必须将该事务已经应用到其磁盘镜像上。除去redo日志，各种清单按照如下规则清理，all-log-tids，in-doubt和decided清单随日志清除而清除，任何时刻如果一个tid事务从redo日志中移除，那么它也会从这些清单中移除。

forced-abort清单中的事务不能按照上述方法移除，因为有可能原始协调者还存活着并且后期需要该信息。为收集这部分垃圾这里采用了epoch号的手段，epoch号是全局单调递增的（系统默认是每小时增加一次）。当前的epoch号保存在每个参与者身上，使用一个很粗糙的同步时钟进行同步，参与者会在每次回复协调者时，将epoch号夹在在消息里。一个事务由协调者赋予epoch号，因此如果一个参与者发现某一个未决事务的epoch号太陈旧，说明原始协调者基本不会再出现了，参与者会投abort票并且可以收集这部分在forced-abort清单中epoch号太陈旧的事务。

####一致性备份

Sinfonia可以为其数据实现事务一致的备份，为实现这一点，每个memory node会获取最后一个已成功提交的在redo日志中的事务，假设是L，将磁盘镜像进行更新以追上L，同时，新事务会被阻止更新磁盘镜像，但不会阻止它们更新redo日志。一旦磁盘镜像追上L，这个磁盘镜像会被复制或者快照。复制或者快照完毕后，对磁盘镜像的更新可以继续，备份也可以从这个磁盘镜像复制品或者快照中同时生成。为保证事务一致性，我们需要尽量让所有memory nodes同时发起该操作，让这个时间点没有尚未解决的事务。Sinfonia还是使用两阶段协议来实现这个目的：第一阶段锁住所有memory nodes的地址空间，阶段2开启上述备份制作步骤然后释放锁。回忆之前介绍过的两阶段协议避免死锁的方法，它对于小规模memory nodes是行的通的，但是备份涉及所有memory nodes，如果还是这种模式获取锁有可能造成系统“饥饿”，因此制作备份的两阶段协议中采用阻塞的方式获取锁，并且需要按照memory nodes的顺序获取锁以防止有一个并发的备份制作请求造成死锁。

####配置

应用使用逻辑memory id去索引memory nodes，与之形成对应的还有一个包含IP地址的物理memory id，逻辑到物理memory id的映射保存在Sinfonia的目录服务节点上，这个配置信息会缓存在应用端。

####简单总结

Sinfonia为大规模分布式系统的设计提供了一种新的范式，基于这种良好抽象构成的系统设计范式，分布式系统设计工作可以从原先令人头痛的容错，分布式协议设计演化成更高层次的，容易实施的数据结构设计。
