---
layout: post
title:  C语言版Try-Catch机制实现
category: articles
tags: database connection-pool mysql c
image:
    feature: head6.jpg
author:
    name:   WuYu
    avatar: bio-photo-alt.jpg
comments: true
share: true
---

#####Exception.h

{% highlight c++ %}

#ifndef EXCEPTION_INCLUDED
#define EXCEPTION_INCLUDED
#include <setjmp.h>

#define T Exception_T
/** @cond hide */
#include <pthread.h>
#ifndef CLANG_ANALYZER_NORETURN
#if defined(__clang__)
#define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
#else
#define CLANG_ANALYZER_NORETURN
#endif
#endif
#define ThreadData_T pthread_key_t
#define ThreadData_set(key, value) pthread_setspecific((key), (value))
#define ThreadData_get(key) pthread_getspecific((key))
typedef struct T {
        const char *name;
} T;
#define EXCEPTION_MESSAGE_LENGTH 512
typedef struct Exception_Frame Exception_Frame;
struct Exception_Frame {
	int line;
	jmp_buf env;
        const char *func;
	const char *file;
	const T *exception;
	Exception_Frame *prev;
        char message[EXCEPTION_MESSAGE_LENGTH + 1];
};
enum { Exception_entered=0, Exception_thrown, Exception_handled, Exception_finalized };
extern ThreadData_T Exception_stack;
void Exception_init(void);
void Exception_throw(const T *e, const char *func, const char *file, int line, const char *cause, ...) CLANG_ANALYZER_NORETURN;
#define pop_Exception_stack ThreadData_set(Exception_stack, ((Exception_Frame*)ThreadData_get(Exception_stack))->prev)
/** @endcond */


/**
 * Throws an exception.
 * @param e The Exception to throw
 * @param cause The cause. A NULL value is permitted, and
 * indicates that the cause is unknown.
 * @hideinitializer
 */
#define THROW(e, cause, ...) \
        Exception_throw(&(e), __func__, __FILE__, __LINE__, cause, ##__VA_ARGS__, NULL)


/**
 * Re-throws an exception. In a CATCH or ELSE block clients can use RETHROW
 * to re-throw the Exception
 * @hideinitializer
 */
#define RETHROW Exception_throw(Exception_frame.exception, \
        Exception_frame.func, Exception_frame.file, Exception_frame.line, NULL)


/**
 * Clients <b>must</b> use this macro instead of C return statements
 * inside a try-block
 * @hideinitializer
 */
#define RETURN switch((pop_Exception_stack,0)) default:return


/**
 * Defines a block of code that can potentially throw an exception
 * @hideinitializer
 */
#define TRY do { \
	volatile int Exception_flag; \
        Exception_Frame Exception_frame; \
        Exception_frame.message[0] = 0; \
        Exception_frame.prev = (Exception_Frame*)ThreadData_get(Exception_stack); \
        ThreadData_set(Exception_stack, &Exception_frame); \
        Exception_flag = setjmp(Exception_frame.env); \
        if (Exception_flag == Exception_entered) {


/**
 * Defines a block containing code for handling an exception thrown in
 * the TRY block.
 * @param e The Exception to handle
 * @hideinitializer
 */
#define CATCH(e) \
                if (Exception_flag == Exception_entered) pop_Exception_stack; \
        } else if (Exception_frame.exception == &(e)) { \
                Exception_flag = Exception_handled;


/**
 * Defines a block containing code for handling any exception thrown in
 * the TRY block. An ELSE block catches any exception type not already
 * catched in a previous CATCH block.
 * @hideinitializer
 */
#define ELSE \
                if (Exception_flag == Exception_entered) pop_Exception_stack; \
        } else { \
                Exception_flag = Exception_handled;


/**
 * Defines a block of code that is subsequently executed whether an
 * exception is thrown or not
 * @hideinitializer
 */
#define FINALLY \
                if (Exception_flag == Exception_entered) pop_Exception_stack; \
        } { \
                if (Exception_flag == Exception_entered) \
                        Exception_flag = Exception_finalized;


/**
 * Ends a TRY-CATCH block
 * @hideinitializer
 */
#define END_TRY \
                if (Exception_flag == Exception_entered) pop_Exception_stack; \
        } if (Exception_flag == Exception_thrown) RETHROW; \
        } while (0)


#undef T
#endif

{% endhighlight %}


#####Exception.cc

{% highlight c++ %}

#define T Exception_T
/* Placeholder for systems exceptions. */
T SQLException = {"SQLException"};
#ifdef ZILD_PACKAGE_PROTECTED
#pragma GCC visibility push(hidden)
#endif
T AssertException = {"AssertException"};
T MemoryException = {"MemoryException"};
/* Thread specific Exception stack */
ThreadData_T Exception_stack;
#ifdef ZILD_PACKAGE_PROTECTED
#pragma GCC visibility pop
#endif
static pthread_once_t once_control = PTHREAD_ONCE_INIT;


/* -------------------------------------------------------- Privat methods */


static void init_once(void) { ThreadData_create(Exception_stack); }


/* ----------------------------------------------------- Protected methods */


#ifdef PACKAGE_PROTECTED
#pragma GCC visibility push(hidden)
#endif

void Exception_init(void) { pthread_once(&once_control, init_once); }

#ifdef PACKAGE_PROTECTED
#pragma GCC visibility pop
#endif


/* -------------------------------------------------------- Public methods */

#ifndef ZILD_PACKAGE_PROTECTED

void Exception_throw(const T *e, const char *func, const char *file, int line, const char *cause, ...) {
        va_list ap;
	Exception_Frame *p = ThreadData_get(Exception_stack);
	assert(e);
	if (p) {
                p->exception = e;
                p->func = func;
                p->file = file;
                p->line = line;
                if (cause) {
                        va_start(ap, cause);
                        vsnprintf(p->message, EXCEPTION_MESSAGE_LENGTH, cause, ap);
                        va_end(ap);
                }
                pop_Exception_stack;
                longjmp(p->env, Exception_thrown);
	} else if (cause) {
                char message[EXCEPTION_MESSAGE_LENGTH + 1];
                va_start(ap, cause);
                vsnprintf(message, EXCEPTION_MESSAGE_LENGTH, cause, ap);
                va_end(ap);
                ABORT("%s: %s\n raised in %s at %s:%d\n", e->name, message, func ? func : "?", file ? file : "?", line);
        } else {
                ABORT("%s: 0x%p\n raised in %s at %s:%d\n", e->name, e, func ? func : "?", file ? file : "?", line);
        }
}

#endif

{% endhighlight %}
