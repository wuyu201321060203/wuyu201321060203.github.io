---
layout: post
title:  OOzdb开发，设计，测试反思
category: articles
tags: ConnectionPool SQL database C++ Boost Muduo
image:
    feature: head10.jpg
author:
    name:   WuYu
    avatar: bio-photo-alt.jpg
comments: true
share: true
---

OOzdb是一个轻量级，高效，易用，可扩展的数据库连接池，基于Muduo网络库，Boost库，使用C++和少许C++11编写而成。作为敝人的第一个开源库作品，我格外用心地对OOzdb进行了UT和ST。ST一次性通过让我爽了一把，但人品估计就此败光，用Google gtest测试框架做UT时报了数不清的错误，排查改正了近两周才搞定所有测试，宣告OOzdb可以正式投入“高校生产环境”中使用。在设计，实现和测试环境中我遇到了很多困难，但正如尼采所说的：“凡是不能毁灭我的，都必将使我更强大”，在解决完所有问题之后，我也收获良多，这里记录一下个人感悟，仅供自己消遣娱乐。

OOzdb基于libzdb3.0，但具有以下5个特征：

1. 采用面向对象设计思想对模块进行了封装与整合，提高了模块的可复用性。
2. 谨遵软件设计的开闭原则，增强了库的可扩展性。
3. 使用C++ RAII技术对资源生命周期进行管理，大大降低了使用者的开发难度，提高了易用性。
4. 只对必要的数据库连接池设施进行开发，强化设计，精简模块，保证库的轻量级。
5. 基于Muduo,Boost，使用C++和C++11进行开发，努力保证代码短小精悍，保证库的高效性。

####设计与实现

OOzdb采用策略模式，核心模块类图如下：

![](/images/libzdb1.png)

- Connection：对数据连接的抽象，维护连接的相关信息，提供数据库所有的基本操作语义。
- PreparedStatement：数据库预处理语句封装，维护预处理语句句柄与待绑定参数信息，提供预处理语句操作语义
- ResultSet：数据库查询操作结果集封装，主要提供用户获取查询结果语义
- ConnectionPool：数据库连接池，维护与管理所有数据库连接，包括连接创建，状态管理和清理工作。ConnectionPool提供显示连接清理接口给用户，也可以通过创建清理线程进行自动清理。

####测试

测试分为ST和UT，ST对库的整体进行了测试，表的增删改查，事务的提交回滚等，一次性通过就不提了。下面重点说一下UT，UT爆出了OOzdb许多问题，让我印象深刻的有以下三个：

- 对象初始化不充分

有的对象有很多成员变量，初始化时一时疏忽漏掉了一两个成员变量，结果在局部作用域下，使用编译器随机分配的值引发错误。

- 对象声明周期管理

虽说有RAII的帮助，但是在代码急剧膨胀情况下，还是会百密一疏，比如下面我遇到的一个情况：
用ResultSetPtr保存查询生成的结果集，ResultSetPtr是ResultSet的智能指针，对于ResultSetPtr r = pre->executeQuery("blalalalal")这样的程序存在一个问题，假如r之前已经存了一个结果，这个结果要被blalalalal查询语句新生成的结果覆盖，两个连续的查询语句使用同一个预处理语句，并且结果集需要保存预处理语句句柄的raw poiunter，这种设计会导致预处理语句无法进行两次连续查询，因为智能指针的赋值会先“减”左边再“加”右边，“减”左边时导致老结果析构（假如这时引用计数为1），析构函数中有预处理句柄解绑定结果集的操作，新生成的结果集由于之前已经对预处理句柄进行了结果集绑定，这时候就会被误删，之后对新结果集的操作会报没有绑定结果集的错误。所以，以后在对象析构时一定要注意是否有与别人共享的并且要删的成员，如果有，要思考删除它是否会产生连锁反应。

- 死锁问题

由于OOzdb支持多线程，需要对一些共有的成员进行加锁操作以避免并发带来的错误。OOzdb只使用一个锁，所以死锁只能是自己锁自己，这点排查很简单，经验就是在使用互斥锁时要考虑使用锁的那部分程序的上下文，全盘考虑问题。

下面是我UT的测试代码，可能还有一些漏洞，欢迎指正。

OOzdb源码和使用文档挂在了我的github上，地址
