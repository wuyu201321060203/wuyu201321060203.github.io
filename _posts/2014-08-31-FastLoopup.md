---
layout: post
title:  列式内存数据库的一种快速索引方案浅析
category: articles
tags: Fast-Loopups In-Memory Column-Store
image:
    feature: head11.jpg
author:
    name:   WuYu
    avatar: bio-photo-alt.jpg
comments: true
share: true
---

最近由于实验室需要设计和实现一个支持OLAP的列式内存数据库，所以对一些典型的同类型数据库产品进行了一番调研。这里我把SAP HANA里基于内存的列式数据库索引引擎p*Time中所使用的索引技术整理和记录了一下，希望对大家能有所帮助。

####wikipedia上对HANA的定义如下：
SAP HANA, short for "High-Performance Analytic Appliance" is an in-memory, column-oriented, relational database management system developed and marketed by SAP AG. It runs massively parallel, thus exploiting the maximum out of multicore processors and subsequently enabling very fast query execution.具体可以参加HANA的白皮书。

基于内存的列式数据库一般都采用读写分离策略，数据更新作用在一个专门为写优化的区域（delta partition），这个区域通常都很小并且采用树结构（比如B类树）的索引来加速更新操作。而只读区域（main partition）一般都很大，并且同样需要建立索引以提高事务和分析的性能。p*Time提出了一套只读区域的索引方案，该方案在查询执行时能急剧降低内存消耗，因此可以快速执行索引查询和联合查询，非常有利于事务和分析型任务。

为了降低数据库操作响应时间和内存消耗，p*Time使用了一种经过转化的索引——Group-Key，从而将列扫描转化为索引查找。

为了更好的节省内存开销，p*Time索引方案中的大部分数据结构都采用了位压缩的方案，说来也很简单。比如在32位机器上，一个整型占用4个字节，这往往都是浪费内存的，因为我们一般都不会用到特别大的数，所以更“经济”的解决方案是如果我们所需要的最大的数为n，那么就把表示这些数的位数限定为logn。

尽管OLAP型业务往往需要操作整个表或者域，甚至对表进行多维度联合查询，但是对于列式数据库中拥有字典索引的列一般采用疏松索引来取代密集索引以获得更高的查找效率。

p*Time所用到的核心数据结构有以下4个，其中前两项是main partition需要的，而后两项就是Group-key需要的数据结构，又叫Group-key Index：
- 排好序的字典
- 位压缩过的属性向量：存储了value-ids，它标识了原始数据在字典中位置。
- 偏移向量表：辅助数据结构，负责把指定的value-id映射到其在属性向量索引表的偏移。
- 属性向量索引表：存储属性向量的相关索引信息。
这几个数据结构之间的关系见下图所示：


举个简单的例子，比如需要查询charlie的所有位置，首先在字典中用二分查找找到charlie，然后读出偏移向量表中相同位置的值（1）和下一项值（3），注意字典项和偏移向量表项一一对应。拿到1和3说明charlie这个单词在属性向量索引表中偏移为1和2，因为偏移向量表中记录的是左闭右开区间。然后在属性向量索引表中偏移为1和2处拿出值5和6，这步一般可以一次性取出值，因为字典中的相同值在属性向量索引表中的相关信息都是连续存放的。5和6就是该字符串的rowID，也就是其位置，而且可以发现属性向量表中偏移为5和6位置的值都为1，恰好是charlie在字典中的偏移。

在拥有字典和属性向量的情况下，如何重建Group-key Index：
1. 生成偏移向量：先创建一个空的偏移向量（每一项都填0），长度和字典长度相同，遍历属性向量查找value-ids的出现次数，比如上图，假如需要根据左面两个数据结构生成Group-key Index，apple的value-id是0，在属性向量中查找0的次数发现只有1个，就在偏移向量第1项填1（0+1），注意填偏移向量表时从第一项开始（所有数据结构都是从0开始的，程序猿应该很好理解）。同理，charlie的value-id是1，在属性向量中查找发现出现2次，在偏移向量第2项填3（1+2），以此类推。
2. 生成属性向量索引表：扫描偏移向量，获取每一项的键值对（key,value），比如（0,0），（1,1），（2,3）......。拿着key去属性向量中查询，比如key 0在属性向量中偏移是4，这是我们要填入属性向量索引表的值，那么填在哪儿呢？key 0对应的value即是要填入的位置，这里是0，所以把4填入属性向量索引表中偏移为0的位置。然后用偏移向量的下一项键值对的值减去本键值对的值来获取该key在偏移向量出现的次数，这里发现1-0=1，说明只出现1次，所以已经填入完毕。但是对于键值对（1,1）发现该key出现的次数是3-1=2次，所以在偏移向量中搜索key 1要搜两次并把其在偏移向量中的位移依次填入属性向量索引表的相关位置，以此类推，直至扫描完偏移向量。

如何生成main partition中的字典和属性向量呢？

如下图所示：

不要被图吓到，其实操作步骤很简单。首先必须要说明一下，我们刚才讲的索引数据结构只适用于main partition，那么对于写优化区域delta partition是怎样进行索引的呢？答案是大名鼎鼎的B+树。图中已经给出了步骤我这里解释一下，首先标示为Inputs Step 1是第一步我们需要的输入，Outputs Step 1就是我们第一步需要输出的东西，包括新字典，辅助性数据结构增量向量表和delta partition的属性向量表。新字典由老字典和delta partition中的B+树合并而成的，我们同时扫描老字典和B+树的叶子节点，按照字符串顺序（字典顺序）做归并排序即可生成新字典，在生成新字典的同时需要生成增量向量表，比如新插入个bodo，这是老字典没有的，就在bodo所在的新字典偏移1开始，依次把增量向量表中的每一项加1，如上图中的X所示。delta partition中的属性向量就根据新字典来填即可。Inputs Step2的输入部分是增量向量，老的属性向量和刚才第一步新生成的属性向量，Outputs Step 2输出的就是新的属性向量，那么它是如何生成的呢？先把老属性向量根据增量向量做一个更新然后和新属性向量做合并，比如Vmj中第一项是4，找到增量向量中偏移为4的项值是1，所以将5（4+1）填入新属性向量第一项，以此类推。全部更新完成后直接把Vdj放到Vmj`末尾，也就是简单地合并即可。

这样新字典和属性向量就生成了，之前还有Group-key Index的偏移向量和属性索引向量的生成，有没有觉得很麻烦，其实还有一种更省内存的方式来同时生成这4个向量数据结构。如下图所示：

这里给出伪代码，试着跟着走一下相信大家就可以理解如何操作了，其实这个算法本身并不是难点，而是如何尽量节省内存开销才是p*Time重点关注的事情，也是它的一个核心技术。
可能大家对此还觉得有些绕，可能是因为之前有一些是HANA 自身设计所导致的特性，建议看一下HANA的白皮书，相信就会有比较深刻的认识。

$y = x^2 +1$
